{"name":"Pat-mat","tagline":" a Full-Feature Pattern Matching Library for JavaScript (or Coffee)","body":"Pat-Mat\r\n==========\r\n\r\nA full-feature [pattern matching](http://en.wikipedia.org/wiki/Pattern_match) library for JavaScript and CoffeeScript\r\n\r\n## Feature\r\n\r\n* Plain Old JavaScript Object as Pattern\r\n* Variable Binding\r\n* Case Class\r\n* Pattern Guard\r\n* Alternative Pattern\r\n* Customizable Extractor\r\n* Concise API\r\n* Automatic Class Annotator\r\n* Enumeration Order Independent\r\n\r\n## Reason\r\n\r\n[There](https://github.com/natefaubion/matches.js) [are](https://github.com/jfd/match-js) [pretty](https://github.com/dherman/pattern-match) [much](https://github.com/pb82/MissMatch) [pattern](https://github.com/puffnfresh/bilby.js) [matching](https://github.com/jiyinyiyong/coffee-pattern) [libraries](https://github.com/bramstein/funcy) [existing](https://github.com/natefaubion/sparkler). However, few of them are feature rich. Even though some libraries are powerful,  they are either deprecated or require advanced [macro](https://github.com/mozilla/sweet.js) system.\r\n\r\nThis repository, highly inspired by Scala, aims at creating a feature-rich pattern matching library while keeping every thing like plain old JavaScript. Being more powerful and concise is this library's _Raison d'Ãªtre_.\r\n\r\nPat-Mat itself was written in CoffeeScript so all the example are also presented in that language. Pat-Mat looks better with Coffee's DSL extensibility. If you don't bother brew a jar of coffee, just add curly braces, `return` and etc. to make it work.\r\n\r\nInstall\r\n---\r\nAssuming you have installed `npm` and NodeJS. Then in your console.\r\n`npm install pat-mat`\r\n\r\nAnd in code:\r\n\r\n```coffee\r\n# import\r\n{Match, Is, parameter, paramSeq} = require('pat-mat')\r\n# rename for eye candy\r\n$ = parameter\r\n$$ = paramSeq\r\n# later use, (username)@(domain).xx\r\nMAIL_REG = /(.*?)@(.*?)\\..+/\r\n\r\n# example usage\r\nm = Match(\r\n  # literal\r\n  Is 42, -> 'meaning of life'\r\n  # Type\r\n  Is Function, -> 'get a function'\r\n  # object\r\n  Is {x: 3, y: 4}, ->  'x is 3, y is 4'\r\n  # alternative\r\n  Is Number, Boolean, -> 'num or func'\r\n  # variable binding\r\n  Is [$, $$], (head, tail) -> head\r\n  # RegExp\r\n  Is MAIL_REG, (s, name, domain) -> name\r\n)\r\n\r\n# match element by calling\r\nm(42) # 'meaning of life'\r\n# Match() returns a function\r\nm(m) # 'get a function'\r\n```\r\n\r\nAnd all patterns are just [POJO](http://en.wikipedia.org/wiki/Plain_Old_Java_Object) -- plain old javascript objects, rather than [string pattern](https://news.ycombinator.com/item?id=4519367). So you still have syntax highlight in your patterns.\r\n\r\nBasic\r\n---\r\n\r\nStarting pattern match is just calling pat-mat's `Match` function. It receive several `case expression` as arguments and return a function that takes element to match. `Case expression` is  the result of `Is` function. `Is` takes at least two arguments: the last one is a function to be called when a match is found, and other arguments before it are patterns.\r\n\r\nCase expressions (and Patterns) are sequentially matched from top to down as passed when calling `Match`. The first matching pattern will trigger the matched function and pass matched variable to the latter.\r\n\r\nPat-Mat provides a `parameter` singleton for variable binding. If `parameter` occurs in pattern, it will be recorded in `Is` expression and be passed to matched function as argument.\r\n\r\nMatched function's return value will be the result of pattern-matching, make sure you do `return`. Matched function will be passed arguments of variable length, depending on the matching pattern. Arguments order is generally left to right, top to down, but that's not guaranteed for object because [ECMA's spec](http://stackoverflow.com/a/5525820). Solution for this will be presented later.\r\n\r\n> NB: Pat-Mat also provides other case expression for different variable binding policies).\r\n\r\nFor now, if it is unclear for you, just reading the following example to see how to use Pat-Mat\r\n\r\n```coffee\r\n{Match, Is, parameter} = require('pat-mat')\r\n\r\n# finding the factorial of n\r\nfact = Match(\r\n  Is 0, -> 1\r\n  Is parameter, (n) -> n * fact(n-1)\r\n)\r\n\r\n# fact is a function\r\nfact(3) # is 6\r\nfact(6) # is 720\r\n```\r\nTo summarize, there are just three points to leverage the basic of Pat-Mat\r\n  * `Match`, call it and pass it several\r\n  * `Is`, case expressions to match. Every `Is` has\r\n  * patterns and matched action. Matched action is just function\r\n\r\nAnd how patterns are composed is just explained in the following section.\r\n\r\nPatterns\r\n----\r\n\r\n### Literals\r\nCheck value literally. It supports all JavaScript primitive values including string, number, `null`, `undefined` and `NaN`\r\nNote that since patterns are just normal JavaScript objects, variables in patterns are passed as their value/reference.\r\n\r\n```coffee\r\nk = 'a string'\r\npatmat = Match(\r\n  Is 42, -> ...\r\n  Is 'a string', ->\r\n  Is k, -> ... # same as above\r\n  Is null, -> ...\r\n  Is undefined, -> ...\r\n  Is NaN, -> ... # matched by isNaN\r\n)\r\n```\r\n\r\n### Parameter\r\nVariables can be captured by using parameter. They are passed as arguments to matched actions.\r\n\r\n``` coffee\r\n# for shorter name\r\n$ = parameter\r\n\r\npatmat = Match(\r\n  Is [$, 2, 3], (p) -> 'p is ' + p\r\n  Is {x: $}, (x) -> 'x is ' + x\r\n)\r\n\r\npatmat([1, 2, 3]) # p is 1\r\npatmat({x: 1}) # x is 1\r\n```\r\n\r\nYou can also use `parameter` as function to specify what kind of value will be captured.\r\n`parameter` takes `pattern` as argument, except for string pattern.\r\n\r\n```coffee\r\n_ = require('pat-mat').wildcard\r\n\r\npatmat = Match(\r\n  Is [$(Number), 2, 3], -> 'matched'\r\n  Is _, -> 'no match'\r\n)\r\n\r\npatmat([1, 2, 3])\r\n# matched\r\npatmat(['str', 2, 3])\r\n# no match\r\n```\r\nIf you worry that enumerating order of object keys is not stable, as specified by ECMA, you can use string to name the parameter.\r\nAnd you need another function to generate `case expression`: `On`.\r\nMatched action in `On` expression receives an plain object as argument, in which the names you assign to parameters are keys.\r\nThe second argument in `parameter` is `pattern`.\r\n\r\n```coffee\r\n_ = require('pat-mat').wildcard\r\nmatchPoint = Match(\r\n  On {x: $('x', Number), $('y')}, (point) -> p.x + p.y\r\n  On _, -> 'not a point'\r\n)\r\n\r\nmatchPoint({x: 3, y: 4}) # 7\r\nmatchPoint({x: '3' , y: 4}) # not a point\r\n```\r\n\r\n### Wildcard\r\n`Match` will throws an `NoMatchError` if no `CaseExpression` fits the element.\r\nYou can use a `wildcard` pattern as the **default** case. Wildcard can also be nested pattern.\r\n\r\n```coffee\r\n_  = require('pat-mat').wildcard\r\npatmat = Match(\r\n  Is [_, _], -> 'two element array as tuple'\r\n  Is _,      -> 'anything else'\r\n)\r\n\r\npatmat([2, 3]) # two element array as tuple\r\npatmat(Array) # anything else\r\n```\r\n\r\n### Array\r\nMatches on entire array or pick up a few elements.\r\nPat-Mat provides `paramSeq` and `wildcardSeq` for matching subarray.\r\n(`Seq` stands for _sequence_)\r\n\r\n```coffee\r\n$ = require('pat-mat').parameter\r\n$$ = require('pat-mat').paramSeq\r\n\r\nsum = Match(\r\n  # $$ captures the subarray\r\n  Is [$, $$], (head, tail)-> head + sum(tail)\r\n  Is [], -> 0\r\n)\r\n\r\nsum([1, 2, 3]) # 6\r\n```\r\n\r\nJust like `wildcard`, `wildcardSeq` does not bind subarray to any variables.\r\nOne array pattern can have one and only one sequence pattern. Otherwise an Error will occurs.\r\n\r\nArray pattern matches all **Array Like**(has `length` property and its elements can be accessed by index) elements. So you can, for example, pass `arguments` to pattern matcher.\r\n\r\n### Object\r\nObject is matched by comparing key-value pairs, so here _Duck Typing_ is conducted.\r\n\r\n```coffee\r\n# will match as long as element has x and y property\r\nmatchPoint = Match(\r\n  Is {x: $, y: $}, (x, y) -> 'get point'\r\n)\r\n\r\nclass Point\r\n  constructor: (@x, @y)\r\n\r\n# take any type\r\nmatchPoint(new Point(3, 4)) # get point\r\n# even the property is null or undefined\r\nmatchPoint({x: 'd', y: null}) # get point\r\n# but not if it has no such key\r\nmatchPoint({x: 1}) # NoMatchError\r\n```\r\n\r\n### Type\r\nIf the pattern is a function, then the function will be treated as a constructor function. The element matched against must be a subtype of that constructor.\r\n\r\n```coffee\r\n\r\nclass Animal\r\nclass Snake extends Animal\r\nclass Python extends Snake\r\nclass Naja extends Snake\r\nclass Frog extends Animal\r\n\r\nfindAnimal = Match(\r\n  Is Python, -> 'large snake'\r\n  Is Snake, -> 'snake'\r\n  Is Animal, -> 'new species'\r\n)\r\n\r\nfindAnimal(new Python) # 'large snake'\r\nfindAnimal(new Naja) # 'snake'\r\nfindAnimal(new Frog) # 'new species'\r\n```\r\n\r\n> NB: `instanceof` is used as subtype checking. [Comparing](https://github.com/bramstein/funcy#patterns) `element.constructor` will violates [Liskov Substitution Principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle)\r\n\r\nFor core JavaScript datatype `Number`, `String`, `Boolean`, their corresponding primitive values are taken as matching elements.\r\n\r\n```coffee\r\n# monoid like mappend\r\nappend = (a, b) -> Match(\r\n  Is [String, String], -> a + b\r\n  Is [Number, Number], -> a + b\r\n  Is [Array, Array], -> a.concat(b)\r\n)(arguments)\r\n```\r\n> NB: Only in `In` case expression is `Type` pattern captured.\r\n\r\n### Regular Expression\r\nRegular Expression is matched against element. If a match is found, the match and its capturing group will be passed to the matched action.\r\n\r\n```coffee\r\nMAIL_REG = /(.*?)@(.*?)\\..*/\r\n\r\nmail = Match(\r\n  Is MAIL_REG, (_, name, domain) -> {name, domain}\r\n  Is _, -> 'no match'\r\n)\r\n\r\nmail('test@mail.com') # {name: 'test', domain: 'mail'}\r\n```\r\n> NB: Regular Expression is only captured in `Is`.\r\n\r\n### Case Class\r\nPat-mat mocks Scala's `case class` by the function `extract`.\r\n_Case classes are regular classes which exports their constructor parameters and which provide a recursive decomposition mechanism via pattern matching._([source](http://www.scala-lang.org/old/node/107))\r\nApplying `extract` to constructor function will return a equivalent constructor function that also doubles as case class pattern.\r\nWith `new`, **extracted** function returns a new instance; without `new`, **extracted** function returns a case class pattern.\r\n\r\nHere is an example. This example uses Coffee's class syntax which is a natural fit for `Case Class`. (That's why Pat-Mat was written in Coffee)\r\n\r\n```coffee\r\nPoint = extract class Point\r\n  constructor: (@x, @y) ->\r\n  # more code\r\n\r\ntakeY = Match(\r\n  Is Point(3, $), (y) -> y\r\n  Is _, -> 'no match'\r\n)\r\n\r\n# a new Point instance\r\ntakeY(new Point(3, 4)) # 4\r\n# a pattern instance\r\ntakeY(Point(3, 4)) # no match\r\n# because x fails to match\r\ntakeY(new Point(4, 4)) # no match\r\n```\r\n\r\nIf you are using JavaScript:\r\n```js\r\nfunction Point(x, y) {\r\n  this.x = x;\r\n  this.y = y;\r\n}\r\nPoint.prototype = {\r\n  // more code\r\n}\r\nvar Point = extract(Point);\r\n\r\nvar takeY = Match(\r\n  Is(Point(3, $), function(y) {\r\n    return y;\r\n  }),\r\n  Is(_, function() {\r\n    return 'no match';\r\n  })\r\n);\r\n\r\ntakeY(new Point(3, 4)); // 4\r\ntakeY(Point(3, 4)); // no match\r\n```\r\n\r\nBy default, Pat-Mat tries to annotate the constructor and to retrieve its parameter name.\r\nIf the element to be matched is an instance of the constructor, then the element's fields with same names with parameter will be recursively matched against the pattern in the case class pattern. So the pattern `Point(3, $)` matches element `p` if `p.x == 3`, and then pass `p.y` to the action as argument if matched.\r\n\r\nHowever, automatic annotation does not work in compressed JavaScript, and fails to match if the fields in constructor are modified during initialization.\r\nFor solution, please refer to [Class Annotator](https://github.com/HerringtonDarkholme/Pat-Mat#class-annotator) section.\r\n\r\nCase Expression\r\n---\r\n`Is/As/On`\r\nObject in JavaScript is a collection of unordered key-value pair. Though expressions like `{x: $, y: $}` will usually keep the order, Pat-Mat gives different `case expression` function to guarantee order.\r\n\r\n`As` will apply arguments to the matched action, but variable binding needs to call `parameter` in pattern.\r\n\r\n```coffee\r\nargCount = -> arguments.length\r\nm = Match(\r\n  # no captured group\r\n  As /test/             , argCount\r\n  # function constructor will not be captured\r\n  As String             , argCount\r\n  # will be captured because it invokes `parameter`\r\n  As {x: $()}           , argCount\r\n  # only capture the first element\r\n  As [$(), __ , Number] , argCount\r\n  # `parameter` itself is not captured\r\n  As $,                   argCount\r\n)\r\n\r\nm('test') # 0\r\nm('ssss') # 0\r\nm({x: 5, y: 5}) # 1\r\nm([3, 3, 3]) # 1\r\nm(null) # 0\r\n```\r\n\r\n`On` will pass an object of which the values are captured variables .`On` requires `NamedParameter`, which means `parameter` should be invoked with a name string as its first argument. The `name` of parameter will be the key of the object.\r\n\r\n```coffee\r\nm = Match(\r\n  On $('n', Number), (m) -> m.n * 2\r\n  On {x: $('x'), y: $('y')}, (m) -> m.x + m.y\r\n  On $(), -> @unnamed[0]\r\n)\r\n\r\nm(2) # 4\r\nm({x: 5, y: 5}) # 10\r\nm(true) # true\r\n```\r\n\r\nUninvoked `parameter` in `As` and `On`, and `parameter` instance other than `NamedParameter` will be stored in `this.unnamed` array and binded to matched function.\r\n\r\n> NB: `Is` stands for _incremental_. `As` stands for _Array_. `On` stands for _Object_. The initials of these functions suggests their argument passing policies.\r\n\r\nMatched Action\r\n---\r\n\r\nMatched action is just plain function. How it receives arguments is dependent on the `case expression`, as specified before.\r\n\r\nMatched action has binded to matching objects to pass more information. You can access the whole match via `this.m` and variables that are not captured by `As`/`On` via `this.unnamed`.\r\n\r\n```coffee\r\nfib = Match(\r\n  As 0, -> 0\r\n  As 1, -> 1\r\n  As Number, -> fib(@m-1) + fib(@m-2)\r\n)\r\nfib(longProcess().getData().getMockNumber().canBeBindedToThisM())\r\n```\r\n\r\nClass Annotator\r\n---\r\n\r\n`extract` is a function that returns a case class constructor.\r\nIt will analyzes the original constructor function by `toString()` and extracts the fields.\r\nHowever, compressed JavaScript will lose the information. You can set the `unapply` static attribute of the **constructor function** to give Pat-Mat a hint.\r\n`unapply` can be `annotation`, an array of string that corresponds to the constructor's argument and instance fields.\r\n\r\n```coffee\r\nPoint = extract class Point\r\n  constructor: (longlongx, longlongy) ->\r\n    @x = longlongx\r\n    @y = longlongy\r\n\r\n  @unapply = ['x', 'y']\r\n\r\np = new Point(3, 4)\r\n# now Pat-Mat will compare p.x and p.y\r\n# Point(3, 4) will match p\r\n```\r\n\r\nIf the fields are modified in constructor, you can set `unapply` to a `transform` function.\r\n`transform` function takes the element to be  matched as argument, and should return an objects with properties specified in `annotation`.\r\n`annotation` is just the array described above. If `unapply` is function, `annotation` is programatically found.\r\n\r\n```coffee\r\nUnitVector = extract class UnitVector\r\n  constructor: (x, y) ->\r\n    norm = Math.sqrt(x*x + y*y)\r\n    @x = x / norm\r\n    @y = y / norm\r\n\r\n  @unapply = (other) ->\r\n    x = other.x\r\n    y = other.y\r\n    norm = Math.sqrt(x*x + y*y)\r\n    # in this case you can also return\r\n    # new UnitVector(other.x, other.y)\r\n    # because the constructor is side-effect free\r\n    return {\r\n      x: x / norm\r\n      y: y / norm\r\n    }\r\n```\r\n\r\nCombining `annotation` and `transform` is okay.\r\nSet `unapply` to an object with `transform` and `annotation`.\r\n\r\n```coffee\r\nCircle = extract class Circle\r\n  constructor: (longlongr) ->\r\n    @r = longlongr\r\n  @unapply = {\r\n    annotation: ['r']\r\n    transform: Match(\r\n      # only transform Circle/Point instance\r\n      Is Circle, -> @m\r\n      Is Point($, $), (x, y) ->\r\n        {r: Math.sqrt(x*x + y*y)}\r\n      Is _, -> null\r\n    )\r\n  }\r\n\r\ngetRadius = Match(\r\n  Is Circle($), (r) -> 'radius: ' + r\r\n)\r\ngetRadius(new Circle(5)) # radius: 5\r\ngetRadius(new Point(3, 4)) # radius: 5\r\ngetRadius({r: 5}) # throw NoMatchError\r\n```\r\n\r\nIf `transform` is defined, then the case class pattern can match any type, as long as the `transform`'s return value is not null.\r\n\r\nAs illustrated above, `transform` can be implemented easily with Pat-Mat.\r\n\r\nCustomized Extractor\r\n---\r\n\r\nMuch similar to class annotator, customized extractor is constructed by passing an `unapply` object to `extract`.\r\n`unapply` should have `annotation` property and optional `transform` property.\r\n\r\nAttention: extractor is not a constructor function.\r\n\r\n```\r\nCircle = extract({\r\n  annotation: ['r']\r\n  transform: Match(\r\n    Is {r: Number}, -> @m # duck typing\r\n    Is Point($, $), (x, y) ->\r\n      {r: Math.sqrt(x*x + y*y)}\r\n    Is _, -> null\r\n  )\r\n})\r\n\r\ngetRadius = Match(\r\n  Is Circle($), (r) -> 'radius: ' + r\r\n)\r\n\r\ngetRadius(new Point(3, 4)) # radius: 5\r\ngetRadius({r: 5}) # radius: 5\r\ngetRadius(new Circle(5)) # TypeError, Circle is not a constructor function\r\n```\r\nPattern Guard\r\n---\r\nPattern guard is also supported by `guard` function.\r\nPattern guard should immediately follow the pattern in case expression. Only one pattern can precede the guard, so no alternative pattern cannot be used.\r\n\r\n```coffee\r\nm = Match(\r\n  Is Number, guard(-> @m%2 == 0), -> 'even'\r\n  Is Number, guard(-> @m%2 == 1), -> 'odd'\r\n  Is wildcard, -> 'not integer'\r\n)\r\nm(2) # is 'even'\r\nm(3) # is 'odd'\r\nm('dd') # is 'not integer'\r\n```\r\n\r\nAPI\r\n===\r\n\r\nStart Match\r\n---\r\n\r\n### `Match(CaseExpressions...) -> Function`\r\nTake serveral `CaseExpression`s as arguments and return a function that matches element.\r\nIf one argument is not `CaseExpression`, then a `TypeError` is thrown.\r\nIf no `CaseExpression` is matched, then an `NoMatchError` is thrown.\r\n\r\nGenerate CaseExpression\r\n---\r\n### `Is(Patterns..., Function) -> CaseExpression`\r\n### `Is(Pattern, Guard, Function) -> CaseExpression`\r\nThe last argument should be a function for matched action. `Is` feeds captured variables to matched action as arguments sequentially.\r\n`Is` also captures Constructor pattern and RegExp pattern.\r\nAnd the whole matching element is binded to `this` keyword, you can access  by `this.m` in the function.\r\n\r\n### `As(Patterns..., Function) -> CaseExpression`\r\n### `As(Pattern, Guard, Function) -> CaseExpression`\r\nThe last argument should be a function for matched action. `As` only captures patterns that is generated by calling `parameter`.\r\nSo `As` does not capture Constructor pattern and RegExp pattern.\r\nAnd the whole matching element is binded to `this` keyword, you can access  by `this.m` in the function.\r\nIf `parameter` occurs in patterns that is not called, they can be accessed by `this.unnamed` array in the function.\r\n\r\n### `On(Patterns..., Function) -> CaseExpression`\r\n### `On(Pattern, Guard, Function) -> CaseExpression`\r\nThe last argument should be a function for matched action. `On` only captures patterns that is named parameter like `$('name', Pattern)`\r\n`On` does not capture Constructor pattern and RegExp pattern.\r\nAnd the whole matching element is binded to `this` keyword, you can access  by `this.m` in the function.\r\nIf parameter is not named, they can be accessed by `this.unnamed` array in the function.\r\n\r\nParameter\r\n---\r\n### `parameter() -> Parameter`\r\n### `parameter(Pattern) -> Parameter`\r\n### `parameter(nameString, Pattern) -> NamedParameter`\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}